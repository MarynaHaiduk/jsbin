<!DOCTYPE html>
<html>
<body>

<div id="root"></div>

<script>
  
  /* Multi-line comment */
  'use strict'; // for ECMAScript 5 (ES5)
  
  //-------------------------------------------------------------------------------
  // VARIABLES ([a-z],[0-9], _, $)
  //-------------------------------------------------------------------------------
  let item1 = 'value';
  const ITEM3 = 'value';
  
  var item2 = 'value';
  var item2; // value1;
  
  //-------------------------------------------------------------------------------
  // DATA TYPES
  // Type Number
  let typeNumber = 123;
  typeNumber = 1/0; // Infinity, type number
  typeNumber = -1/0; // -Infinity, type number
  typeNumber = 'num'/2; // NaN, type number
  // find out if a value is a number
  isNaN(typeNumber); // returns true because x is Not a Number
  
  // Type BigInt
  const typeBigInt = 10n; // type bigint, support only in Firefox, Chrome
  
  // Type String
  let typeString = "abc";  // type string
  typeString = `${1 + 2}`; // 3
  typeString = `${"1 + 2"}`; // "1 + 2"
  
  // Type Boolean
  let typeBoolean = true;
  
  // Type Null (declare when the value is not known)
  const typeNull = null; // type object
  
  // Type Undefined (without any value, used to check if a variable has assigned)
  let typeUndefined;  // type undefined
  
  // Type Symbol (используется для создания уникальных идентификаторов объектов)
  const typeSymbol = Symbol("id"); // type symbol
  
  // Type Object
  let x = {firstName: "John", lastName: "Doe"};
  
  // Check Type (syntax: typeof(x) or typeof x)
  console.log(typeof Math); // type object (встроенный объект, матоперации)
  console.log(typeof alert); // type function (т.к. alert является функцией)
  
  //-------------------------------------------------------------------------------
  // OUTPUT
  //-------------------------------------------------------------------------------
  console.log("console.log text");
  console.error('This is an error');
  console.warn('This is a warning');
  
  document.write("document.write text");
  document.getElementById("root").innerHTML = "InnerHTML text";
  
  window.alert('window.alert text');
  [1, 2].forEach(alert); // 1 2
  
  prompt("text", 123); // вернёт текст, или null если ввод отменён
  // prompt("text", ""); // <-- для IE без значения, иначе IE установит "undefined"
  
  confirm("Question"); // возвращает true, если нажата OK, иначе false
  
  //-------------------------------------------------------------------------------
  // ARITHMETIC OPERATIONS
  //-------------------------------------------------------------------------------
  let a = 1, b = 2, c = 3;
  let calc = a + b;
  calc = a - b;
  calc = a * b;
  calc = a / b;
  calc = a % b;
  calc = a ** b;
  calc = 5 % 2; // 1, reminder
  calc =  2 ** 2; // 4
  calc = 4 ** (1/2); // 2 (квадратного корня)
  calc = 8 ** (1/3); // 2 (кубический корень)
  
  // Если одно из слагаемых строка, тогда и все остальные приводятся к строкам
  calc = 1 + '2'; // '12'
  calc = '1' + 2; // '12'
  calc = 2 + 2 + '1';  // '41'
  calc = 4 + 5 + "px"; // '9px'
  calc = "$" + 4 + 5; // '$45'
  calc = "" + 1 + 0; // '10', cложение со строкой "" + 1 преобразует 1 к строке
  calc = "" - 1 + 0; // -1, вычитание только c числами, строка "" приводится к 0
  calc = " \t \n" - 2; // -2, вычитание, пробелы, \t, \n по краям игнорируются
  
  //-------------------------------------------------------------------------------
  // OPERATOR PRESEDENCE
  //-------------------------------------------------------------------------------
  // Если приоритет одинаковый, то порядок выполнения – слева направо.
  // У унарных операторов приоритет выше, чем у бинарных.
  // У присваивания самый низкий приоритет.
  
  a = b = c = 2 + 2; // c=4, b=4, a=4 (присваивается переменным слева: c, b и a.
  c = 3 - (a = b + 1); // a=5, c=-2, можно использовать как часть выражения
  
  // Инкремент/декремент
  // Можно применить только к переменной, 5++ приведёт к ошибке.
  let counter = 0;
  // alert( counter++ ); // 0
  calc = 0;
  // префиксная форма возвращает НОВОЕ значение, после увеличения
  let result = ++calc; // result=1, calc=1
  // постфиксная форма возвращает СТАРОЕ (до увеличения/уменьшения числа)
  result = calc++; // result=0, calc=1
  result = calc--; // result=1, calc=0
  // Приоритет инкремента/декремента выше чем у арифметических выражений!!!
  counter = 1;
  calc = 2 * ++counter; // calc=4, counter=2
  counter = 1;
  calc = 2 * counter++; // calc=2, counter=2
  // Чему будут равны переменные a, b, c и d
  a = 1, b = 1, c = ++a; let d = b++; // a = 2, b = 2, c = 2, d = 1
  
  // Побитовые операторы (работают с 32-разрядными целыми числами (при
  // необходимости приводят к ним)) и &, или |, исключающее или ^, не ~,
  // левый <<, правый сдвиг >>, правый сдвиг с заполнением нулями >>>
  
  //Сокращённая арифметика с присваиванием
  // Вызов с присваиванием выполнится, как обычное присваивание, после операций
  calc = 2;
  calc *= 3 + 5; // calc=16 (равнозначно n *= 8)
  
  // Оператор запятая (имеет очень низкий приоритет, ниже присваивания).
  // Возвращает последний результат
  a = (1 + 2, 3 + 4); // a=7, каждое выполняется, но возвращается последний
  a = 1 + 2, 3 + 4; // a=3, присвоит a=3, то, что идёт дальше, будет проигнорировано
  // Используется, чтобы сделать несколько действий в одной строке.
  // for (a = 1, b = 3, c = a * b; a < 10; a++) { ...}
  
  //-------------------------------------------------------------------------------
  // LOGICAL OPERATORS (||, &&, !)
  //-------------------------------------------------------------------------------
  // Note: Приоритет && больше, чем у ||. Приоритет как: (a && b) || (c && d)
  // Note: Приоритет НЕ ! является наивысшим из всех логических операторов,
  // поэтому он всегда выполняется первым, перед && или ||.
  
  // ИЛИ «||» находит первое истинное значение
  let firstTrue =  null || undefined || 15 || 0; // 15
  // Вычисляет операнды слева направо. Операнды конвертирует в логическое значение.
  // Если результат true, останавливается и возвращает значение этого операнда.
  // Если все операнды являются ложными (false), возвращает последний из них.
  // Значение возвращается в исходном виде, без преобразования.
  
  // И «&&» находит первое ложное значение
  let firstFalse = 1 && null && 0 && undefined && 2; // null
  firstFalse = 1 && 5; // 5
  // Вычисляет операнды слева направо. Операнды конвертирует в логическое значение.
  // Если результат false, останавливается и возвращает значение этого операнда.
  // Если все операнды были истинными, возвращается последний.
  
  // ! (НЕ)
  // Приводит аргумент к true/false и возвращает противоположное значение.
  result = !true; // false
  result =  !0; // true
  // Двойное НЕ используют для преобразования значений к логическому типу
  result = !!"non-empty string"; // true
  result = !!null; // false, или коротко Boolean(null); // false
  
  alert( alert(1) || 2 || alert(3) ); //  сначала выведет 1, затем 2
  // Выполнит alert(1), получит undefined и пойдёт дальше искать истинное значение
  alert( alert(1) && alert(2) ); // 1, а затем undefined
  alert( null || 2 && 3 || 4 ); // 3, равнозначно: null || 3 || 4
  
  // условие if для проверки, что значение age НЕ находится в диапазоне 14 и 90 вкл.
  // Первый вариант: if (!(age >= 14 && age <= 90))
  // Второй вариант: if (age < 14 || age > 90)
  
  //-------------------------------------------------------------------------------
  // MATH
  //-------------------------------------------------------------------------------
  Math.pow(5,2);   // result is 25
  
  //-------------------------------------------------------------------------------
  // ARRAYS - Store multiple values in a variable
  //-------------------------------------------------------------------------------
  const numbers = [1,2,3,4,5];
  const fruits = ['apples', 'oranges', 'pears', 'grapes'];
  console.log(numbers, fruits);
  console.log(fruits[1]);  // Get one value - Arrays start at 0
  fruits[4] = 'blueberries';  // Add value
  fruits.push('strawberries');  // Add value using push()
  fruits.unshift('mangos');  // Add to beginning
  fruits.pop();  // Remove last value
  console.log(Array.isArray(fruits));  // Check if array
  console.log(fruits.indexOf('oranges'));  // Get index
  
  //-------------------------------------------------------------------------------
  // STRINGS
  //-------------------------------------------------------------------------------
  let s = "";
  s.includes("1"); // returns false
  name = "One";
  let age = 25;
  console.log('My name is ' + name + ' and I am ' + age); // Concatenation
  console.log(`My name is ${name} and I am ${age}`); // Template literal
  // String methods & properties
  s = 'Hello World';
  let val;
  val = s.substring(0, 5);  // Get sub string
  val = s.split('');  // Split into array
  
  // Strings are immutable: Strings cannot be changed, only replaced.
  let txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  val = txt.length;  // 26, string length
  
  console.log(txt.indexOf("B")); // 1, 1st occurrence of text in a string or -1
  console.log(txt.lastIndexOf("B")); // 1, last occurrence of text in a string or -1
  // Both methods accept a second parameter as the starting position for the search:
  console.log(txt.indexOf("B"), 1); // 1, 1st occurrence of text in a string or -1
  console.log(txt.lastIndexOf("B"), 1); // 1, searches from the end to the beginning
  
  console.log(txt.search("B")); // search values with regular expressions
  
  console.log(txt.slice(0, 3)); // ABC, slice(start, end)
  console.log(txt.slice(10)); // KLMNOPQRSTUVWXYZ, slice(start, end)
  // Negative positions do not work in Internet Explorer 8 and earlier.
  console.log(txt.slice(-10)); // QRSTUVWXYZ, slice(start, end)
  console.log(txt.slice(-3, -1)); // XY, slice(start, end)
  
  console.log(txt.substring(0, 3)); // ABC, cannot accept negative indexes
  console.log(txt.substring(10)); // KLMNOPQRSTUVWXYZ
  
  console.log(txt.substr(0, 3)); // ABC, 2nd parameter is the length!!!
  console.log(txt.substr(10)); // KLMNOPQRSTUVWXYZ
  console.log(txt.substr(-4)); // WXYZ, the position counts from the end of the string
  
  // By default, the replace() method replaces only the first match (insensitive)
  console.log(txt.replace("A", "*")); // *BCDEFGHIJKLMNOPQRSTUVWXYZ, returns a new string
  // !BCDEFGHIJKLMNOPQRSTUVWXYZ, to replace case insensitive with an /i flag
  console.log(txt.replace(/a/i,"!"));
  // To replace all matches, use a regular expression with a /g flag (global match)
  console.log(txt.replace(/A/g,"!")); // !BCDEFGHIJKLMNOPQRSTUVWXYZ
  
  console.log(txt.replace(/A/g,"!"));
  
  val = txt.toUpperCase(); // Converting to Upper Case
  val = txt.toLowerCase(); // Converting to Lower Case
  val = "123".concat("45", "67"); // '1234567', joins two or more strings
  val = "  13 ".trim(); // '13', removes whitespace from both sides of a string
  val = " 13".replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); //for IE8 or lower
  
  console.log("123".charAt(0)); // 1, returns the character at a specified index
  console.log("123".charCodeAt(0)); // 49, returns the unicode of character at index
  
  console.log(txt[1]); // 'B', does not work in IE7 or earlier
  // If no character is found, [ ] returns undefined, while charAt() returns an empty string
  
  console.log("1,2,3".split(",")); // ["1", "2", "3"], Converting a String to an Array
  console.log("1,2,3".split(""));  // ["1", ",", "2", ",", "3"], Split in characters
  
  //-------------------------------------------------------------------------------
  // OBJECT LITERALS
  //-------------------------------------------------------------------------------
  const person = {
    firstName: 'John',
    lastName: 'Doe',
    age: 30,
    hobbies: ['music', 'movies', 'sports'],
    address: {
      street: '50 Main st',
      city: 'New York',
      state: 'NY'
    },
    fullName: function() {
      return this.firstName + " " + this.lastName;
    }
  }
  
  console.log(person.firstName); // Get single value
  console.log(person.hobbies[1]);  // Get array value
  console.log(person.address.city);  // Get embedded object
  console.log(person.fullName()); // function definition, stored as a property value
  person.email = 'jdoe@gmail.com';  // Add property
  
  // Array of objects
  const todos = [
    {
      id: 1,
      text: 'Text1',
      isComplete: false
    },
    {
      id: 2,
      text: 'Text2',
      isComplete: false
    },
    {
      id: 3,
      text: 'Text3',
      isComplete: true
    }
  ];
  
  console.log(todos[1].text);  // Get specific object value
  console.log(JSON.stringify(todos));  // Format as JSON
  
  //-------------------------------------------------------------------------------
  // Do Not Declare Strings, Numbers, and Booleans as Objects!
  x = String();        // Declares x as a String object, type object
  var y = Number();    // Declares y as a Number object
  var z = Boolean();   // Declares z as a Boolean object
  // Comparing two JavaScript objects will always return false.
  
  //-------------------------------------------------------------------------------
  // Операторы сравнения (>, <, <=, >=, ==, !=) возвращают значение true/false
  //-------------------------------------------------------------------------------
  calc = 4 > 1; // calc=true, type boolean
  
  calc = 'A' > 'Z'; // false, используется «алфавитный» или «лексикографический» порядок
  // большей считается более длинная строка 'asdf' > 'asd'
  // имеет значение регистр символов 'a' > 'A'
  
  // при сравнении значений разных типов JavaScript приводит каждое из них к числу
  calc = '2' > 1; // true, 2>1
  calc = '01' == 1; // true, строка '01' становится числом 1
  calc = true == 1; // логическое значение true становится 1, а false – 0
  calc = Boolean(0); // false
  calc = Boolean('0'); // true
  
  //Оператор строгого равенства === проверяет равенство без приведения типов
  calc = 0 == false; // true
  calc = '' == false; // true
  calc = 0 === false; // false, так как сравниваются разные типы
  calc = null === undefined; // false
  calc = null == undefined; // true, равны друг другу и не равны никаким другим значениям
  
  // При использовании математических операторов и других операторов сравнения < > <= >=
  // Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN
  calc =  null > 0;  // false
  calc =  null == 0; // false,  для == значений undefined и null ни к чему не приводятся
  calc =  null >= 0; // true, сравнения > < >= <= преобразуют null в 0
  
  // Значение undefined несравнимо с другими. Возвращает false при любых сравненияx c NaN
  calc = undefined > 0; // false, undefined преобразуется в NaN,
  calc = undefined < 0; // false
  calc = undefined == 0; // false, undefined равно только null и ничему больше
  
  // Note: осторожно при сравнении с undefined/null, кроме строгого равенства ===.
  // Не используйте сравнения >= > < <= с переменными, которые могут быть null/undefined.
  // Если переменная может принимать эти значения, то добавьте для них отдельные проверки.
  
  calc = 5 > 4; // true
  calc = "ананас" > "яблоко"; // false, Используется посимвольное сравнение
  calc = "2" > "12"; // true, символ первой строки "2" больше, чем первый символ второй "1"
  calc = undefined == null; // true, Значения null и undefined равны друг другу при ==
  calc = undefined === null; // false
  calc = null == "\n0\n"; // false, null равен только undefined!!!
  calc = null === +"\n0\n"; // false, Строгое сравнение разных типов
  
  //-------------------------------------------------------------------------------
  // TYPE CONVERSION
  // Численное преобразование происходит в остальных мат. функциях и выражениях
  calc = "6" / "2"; // 3, type number
  
  // Преобразование к числу, унарный плюс +
  calc = +1; // 1, унарный плюс ничего не делает с числами
  calc = +-2;  // -2
  calc = +'2';  // 2, преобразует нечисла в числа (то же самое, что и Number(...))
  calc = +true; // 1
  calc = +"";   // 0
  
  let apples = "2", oranges = "3";
  calc = apples + oranges; // "23", бинарный плюс сложит их как строки
  calc = +apples + +oranges; // 5, оба операнда предварительно преобразованы в числа
  calc = Number(apples) + Number(oranges); // 5, более длинный вариант
  
  // Convert to string
  let convertToString = String(123); // '123', type string
  // By default, JavaScript displays numbers as base 10 decimals.
  // But you can use the toString() method to output numbers from base 2 to base 36.
  // Hexadecimal is base 16. Decimal is base 10. Octal is base 8. Binary is base 2.
  let myNumber = 32;
  myNumber.toString(10);  // returns 32
  myNumber.toString(32);  // returns 10 (decimal)
  myNumber.toString(16);  // returns 20 (hexadecimal)
  myNumber.toString(8);   // returns 40 (octal)
  myNumber.toString(2);   // returns 100000 (binary)
  
  // Convert to number
  let convertToNumber = Number("123"); // 123, type number
  convertToNumber = Number("123z"); // NaN, type number
  // пробельные символы по краям обрезаются. Если остаётся пустая строка,
  // то 0, иначе «считывается» число. При ошибке результат NaN.
  convertToNumber = Number(undefined); // undefined преобразуется в NaN!!!
  convertToNumber = Number(null); // null преобразуется в 0!!!
  convertToNumber = Number(true); // true/false  преобразуется в 1/0
  
  // Convert to boolean
  // Значения: 0, null, undefined, NaN, "" преобразуются в false,
  // любое другое значение в true
  // "0" и строки из одних пробелов типа " " при логическом преобразовании всегда true
  calc = Boolean(0); // false!!!
  calc = Boolean("0"); // true!!!
  calc = Boolean(""); // false
  calc = Boolean(" "); // true (если строка не пустая, то она всегда true!!!)
  
  calc = true + false; // 1, type number
  calc = null + 1; // 1, type number (null становится 0 после численного преобразования)
  calc = undefined + 1; // NaN, type number (undefined становится NaN после числ.преобразования)
  
  // If you use NaN in a mathematical operation, the result will also be NaN
  calc = NaN + 1; // NaN
  calc = NaN + '1'; // NaN1
  
  // Численное преобразование
  let convertToInt = parseInt("1");  // 1, type number
  let convertToFloat = parseFloat("1"); // 1, type number
  
  //-------------------------------------------------------------------------------
  // LOOPS
  //-------------------------------------------------------------------------------
  // For
  for (let i = 0; i <= 10; i++){
    console.log(`For Loop Number: ${i}`);
  }
  
  // While
  let i = 0;
  
  while (i <= 10) {
    console.log(`While Loop Number: ${i}`);
    i++;
  }
  
  // Do While (will execute at least once)
  i = 0;
  do {
    console.log(`Do While Loop Number: ${i}`);
    i++;
  } while (i < 3);
  
  // Loop Through Arrays
  // For Loop
  for(let i = 0; i < todos.length; i++){
    console.log(` Todo ${i + 1}: ${todos[i].text}`);
  }
  
  // For...of Loop
  for(let todo of todos) {
    console.log(todo.text);
  }
  
  // Continue
  for (let i = 0; i < 10; i++) {
    if (i % 2 == 0) continue;
    console.log(i); // 1, затем 3, 5, 7, 9
  }
  
  // Break
  let sum = 0;
  while (true) {
    let value = +prompt("Enter number", '');
    if (!value) break; // (*)
    sum += value;
  }
  console.log( 'Sum: ' + sum );
  
  // labelName: for(...) { ...} выйти одновременно из нескольких уровней цикла сразу.
  // Вызов break <labelName> ищет ближайший внешний цикл с меткой и переходит в его конец
  outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      let input = prompt(`Значение на координатах (${i},${j})`, '');
      // если пустая строка или Отмена, то выйти из обоих циклов
      if (!input) break outer; // (*)
      // сделать что-нибудь со значениями...
    }
  }
  alert('Готово!');
  
  // Директива continue также может быть использована с меткой. В этом случае
  // управление перейдёт на следующую итерацию цикла с меткой.
  // Вызов break/continue возможен только внутри цикла, и метка должна
  // находиться где-то выше этой директивы.
  // let i = 0; while (++i < 5) alert( i ); // От 1 до 4
  // let i = 0; while (i++ < 5) alert( i ); // От 1 до 5
  
  //-------------------------------------------------------------------------------
  // CONDITIONALS
  //-------------------------------------------------------------------------------
  // Число 0, пустая строка "", null, undefined и NaN становятся false
  
  // Simple If/Else Statement
  const x = 30;
  if (x === 10) {
    console.log('x is 10');
  } else if (x > 10) {
    console.log('x is greater than 10');
  } else {
    console.log('x is less than 10')
  }
  
  // Switch
  let color = 'blue';
  switch(color) {
    case 'red':
      console.log('color is red');
    case 'blue':
      console.log('color is blue');
    default:
      console.log('color is not red or blue')
  }
  
  // Ternary operator / Shorthand if
  const z = (color === 'red') ? 10 : 20;
  
  let login;
  let message = (login == 'Сотрудник') ? 'Привет' :
      (login == 'Директор') ? 'Здравствуйте' :
          (login == '') ? 'Нет логина' :
              '';
  
  //-------------------------------------------------------------------------------
  // JavaScript Numbers (Always 64-bit Floating Point)
  //-------------------------------------------------------------------------------
  // 64 bits: the fraction 0 to 51, the exponent in 52 to 62, and the sign in bit 63
  x = 3.14;    // number with decimals
  y = 3;       // number without decimals
  x = 123e5;    // 12300000, with exponent
  y = 123e-5;   // 0.00123
  
  // Integers (numbers without a period or exponent notation) are accurate up to 15 digits
  x = 999999999999999;   // x will be 999999999999999
  y = 9999999999999999;  // y will be 10000000000000000
  
  // The maximum number of decimals is 17, but floating point arithmetic is not always 100% accurate
  x = 0.2 + 0.1;         // x will be 0.30000000000000004
  // To solve the problem above, it helps to multiply and divide
  x = (0.2 * 10 + 0.1 * 10) / 10;       // x will be 0.3
  
  x = 0xFF; // x will be 255, preceded by 0x, are interpreted as hexadecimal
  // Never write a number with a leading zero (like 07).
  // Some JavaScript versions interpret numbers as octal if they are written with a leading zero.
  
  //-------------------------------------------------------------------------------
  /*
  Список зарезервированных слов в JavaScript:
  abstract, break, byte, case, catch, char, class, const, continue,
  debugger, default, delete, do, double, enum, export, extends, final, finally, float,
  for, function, goto, implements, import, in, instanceof, int, inteface, long,
  native, null, package, private, protected, public, return, short, static, super,
  switch, synchronized, this, throw, throws, transient, try, volatile, void, while, with
  */
  //-------------------------------------------------------------------------------

  //------------------------------------------------------------

  // Подключение внешнего файла
  <script src="js/myscript.js"></script>

//------------------------------------------------------------

alert('Hello');		     // выведет всплывающее окно
console.log(5+5);      // выводит в консоли браузера
document.write(5+7);   // пишет информацию на веб-страницу

//------------------------------------------------------------
// Проверить к какому типу относится
var x = "5";
console.log(x)
console.log(typeof x)

//------------------------------------------------------------

// функции prompt() в браузере выводится диалоговое окно с предложением ввести некоторое значение
// Второй аргумент в этой функции указывает на значение, которое будет использоваться по умолчанию.
// Функция возвращает сроку!!!
var a = prompt('Enter something', 100);
var b = prompt();
alert(a + b);                					// сумма строк
alert('Сумма:' + parseInt(a) + parseInt(b));	// сумма чисел

</script>
</body>
</html>

<!DOCTYPE html>
<html>
<body>

<div id="root"></div>

<script>

/* Multi-line comment */
'use strict'; // for ECMAScript 5 (ES5)

//-------------------------------------------------------------------------------
// VARIABLES ([a-z],[0-9], _, $)   
//-------------------------------------------------------------------------------
let item1 = 'value';
const ITEM3 = 'value';

var item2 = 'value';  
var item2; // value1; 

//-------------------------------------------------------------------------------
// DATA TYPES 
// Type Number
let typeNumber = 123; 
typeNumber = 1/0; // Infinity, type number
typeNumber = -1/0; // -Infinity, type number
typeNumber = 'num'/2; // NaN, type number
// find out if a value is a number
isNaN(typeNumber); // returns true because x is Not a Number

// Type BigInt
const typeBigInt = 10n; // type bigint, support only in Firefox, Chrome

// Type String
let typeString = "abc";  // type string
typeString = `${1 + 2}`; // 3
typeString = `${"1 + 2"}`; // "1 + 2"

// Type Boolean
let typeBoolean = true;

// Type Null (declare when the value is not known)
const typeNull = null; // type object

// Type Undefined (without any value, used to check if a variable has assigned)
let typeUndefined;  // type undefined

// Type Symbol (используется для создания уникальных идентификаторов объектов)
const typeSymbol = Symbol("id"); // type symbol

// Type Object 
let x = {firstName: "John", lastName: "Doe"};

// Check Type (syntax: typeof(x) or typeof x)
console.log(typeof Math); // type object (встроенный объект, матоперации)
console.log(typeof alert); // type function (т.к. alert является функцией)

//-------------------------------------------------------------------------------
// OUTPUT
//-------------------------------------------------------------------------------
console.log("console.log text");
console.error('This is an error');
console.warn('This is a warning');

document.write("document.write text");
document.getElementById("root").innerHTML = "InnerHTML text";

window.alert('window.alert text');  
[1, 2].forEach(alert); // 1 2

prompt("text", 123); // вернёт текст, или null если ввод отменён
// prompt("text", ""); // <-- для IE без значения, иначе IE установит "undefined"

confirm("Question"); // возвращает true, если нажата OK, иначе false

//-------------------------------------------------------------------------------
// ARITHMETIC OPERATIONS
//-------------------------------------------------------------------------------
let a = 1, b = 2, c = 3;
let calc = a + b;
calc = a - b;
calc = a * b;
calc = a / b;
calc = a % b;
calc = a ** b;
calc = 5 % 2; // 1, reminder
calc =  2 ** 2; // 4
calc = 4 ** (1/2); // 2 (квадратного корня)
calc = 8 ** (1/3); // 2 (кубический корень)

// Если одно из слагаемых строка, тогда и все остальные приводятся к строкам
calc = 1 + '2'; // '12'
calc = '1' + 2; // '12'	
calc = 2 + 2 + '1';  // '41'
calc = 4 + 5 + "px"; // '9px'
calc = "$" + 4 + 5; // '$45'
calc = "" + 1 + 0; // '10', cложение со строкой "" + 1 преобразует 1 к строке
calc = "" - 1 + 0; // -1, вычитание только c числами, строка "" приводится к 0
calc = " \t \n" - 2; // -2, вычитание, пробелы, \t, \n по краям игнорируются

//-------------------------------------------------------------------------------
// OPERATOR PRESEDENCE 
//-------------------------------------------------------------------------------
// Если приоритет одинаковый, то порядок выполнения – слева направо.
// У унарных операторов приоритет выше, чем у бинарных. 
// У присваивания самый низкий приоритет.

a = b = c = 2 + 2; // c=4, b=4, a=4 (присваивается переменным слева: c, b и a. 
c = 3 - (a = b + 1); // a=5, c=-2, можно использовать как часть выражения

// Инкремент/декремент
// Можно применить только к переменной, 5++ приведёт к ошибке.
let counter = 0;
// alert( counter++ ); // 0
calc = 0; 
// префиксная форма возвращает НОВОЕ значение, после увеличения
let result = ++calc; // result=1, calc=1
// постфиксная форма возвращает СТАРОЕ (до увеличения/уменьшения числа)
result = calc++; // result=0, calc=1
result = calc--; // result=1, calc=0
// Приоритет инкремента/декремента выше чем у арифметических выражений!!!
counter = 1;
calc = 2 * ++counter; // calc=4, counter=2
counter = 1;
calc = 2 * counter++; // calc=2, counter=2
// Чему будут равны переменные a, b, c и d
a = 1, b = 1, c = ++a; let d = b++; // a = 2, b = 2, c = 2, d = 1 

// Побитовые операторы (работают с 32-разрядными целыми числами (при 
// необходимости приводят к ним)) и &, или |, исключающее или ^, не ~, 
// левый <<, правый сдвиг >>, правый сдвиг с заполнением нулями >>> 

//Сокращённая арифметика с присваиванием
// Вызов с присваиванием выполнится, как обычное присваивание, после операций
calc = 2;
calc *= 3 + 5; // calc=16 (равнозначно n *= 8)

// Оператор запятая (имеет очень низкий приоритет, ниже присваивания). 
// Возвращает последний результат
a = (1 + 2, 3 + 4); // a=7, каждое выполняется, но возвращается последний
a = 1 + 2, 3 + 4; // a=3, присвоит a=3, то, что идёт дальше, будет проигнорировано
// Используется, чтобы сделать несколько действий в одной строке.
// for (a = 1, b = 3, c = a * b; a < 10; a++) { ...}

//-------------------------------------------------------------------------------
// LOGICAL OPERATORS (||, &&, !)
//-------------------------------------------------------------------------------
// Note: Приоритет && больше, чем у ||. Приоритет как: (a && b) || (c && d)
// Note: Приоритет НЕ ! является наивысшим из всех логических операторов, 
// поэтому он всегда выполняется первым, перед && или ||.

// ИЛИ «||» находит первое истинное значение
let firstTrue =  null || undefined || 15 || 0; // 15 
// Вычисляет операнды слева направо. Операнды конвертирует в логическое значение. 
// Если результат true, останавливается и возвращает значение этого операнда.
// Если все операнды являются ложными (false), возвращает последний из них.
// Значение возвращается в исходном виде, без преобразования.

// И «&&» находит первое ложное значение
let firstFalse = 1 && null && 0 && undefined && 2; // null
firstFalse = 1 && 5; // 5
// Вычисляет операнды слева направо. Операнды конвертирует в логическое значение. 
// Если результат false, останавливается и возвращает значение этого операнда.
// Если все операнды были истинными, возвращается последний.

// ! (НЕ) 
// Приводит аргумент к true/false и возвращает противоположное значение.
result = !true; // false
result =  !0; // true
// Двойное НЕ используют для преобразования значений к логическому типу
result = !!"non-empty string"; // true
result = !!null; // false, или коротко Boolean(null); // false

alert( alert(1) || 2 || alert(3) ); //  сначала выведет 1, затем 2
// Выполнит alert(1), получит undefined и пойдёт дальше искать истинное значение
alert( alert(1) && alert(2) ); // 1, а затем undefined
alert( null || 2 && 3 || 4 ); // 3, равнозначно: null || 3 || 4

// условие if для проверки, что значение age НЕ находится в диапазоне 14 и 90 вкл.
// Первый вариант: if (!(age >= 14 && age <= 90))
// Второй вариант: if (age < 14 || age > 90)

//-------------------------------------------------------------------------------
// ARRAYS - Store multiple values in a variable
//-------------------------------------------------------------------------------
const numbers = [1,2,3,4,5];
const fruits = ['apples', 'oranges', 'pears', 'grapes'];
console.log(numbers, fruits);
console.log(fruits[1]);  // Get one value - Arrays start at 0
fruits[4] = 'blueberries';  // Add value
fruits.push('strawberries');  // Add value using push()
fruits.unshift('mangos');  // Add to beginning
fruits.pop();  // Remove last value
console.log(Array.isArray(fruits));  // Check if array
console.log(fruits.indexOf('oranges'));  // Get index

//-------------------------------------------------------------------------------
// STRINGS
//-------------------------------------------------------------------------------
let s = "";
s.includes("1"); // returns false
name = "One";
let age = 25;
console.log('My name is ' + name + ' and I am ' + age); // Concatenation
console.log(`My name is ${name} and I am ${age}`); // Template literal
// String methods & properties
s = 'Hello World';
let val;
val = s.substring(0, 5);  // Get sub string
val = s.split('');  // Split into array

// Strings are immutable: Strings cannot be changed, only replaced.
let txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
val = txt.length;  // 26, string length 

console.log(txt.indexOf("B")); // 1, 1st occurrence of text in a string or -1
console.log(txt.lastIndexOf("B")); // 1, last occurrence of text in a string or -1
// Both methods accept a second parameter as the starting position for the search:
console.log(txt.indexOf("B"), 1); // 1, 1st occurrence of text in a string or -1
console.log(txt.lastIndexOf("B"), 1); // 1, searches from the end to the beginning

console.log(txt.search("B")); // search values with regular expressions

console.log(txt.slice(0, 3)); // ABC, slice(start, end)
console.log(txt.slice(10)); // KLMNOPQRSTUVWXYZ, slice(start, end)
// Negative positions do not work in Internet Explorer 8 and earlier.
console.log(txt.slice(-10)); // QRSTUVWXYZ, slice(start, end)
console.log(txt.slice(-3, -1)); // XY, slice(start, end)

console.log(txt.substring(0, 3)); // ABC, cannot accept negative indexes
console.log(txt.substring(10)); // KLMNOPQRSTUVWXYZ

console.log(txt.substr(0, 3)); // ABC, 2nd parameter is the length!!!
console.log(txt.substr(10)); // KLMNOPQRSTUVWXYZ
console.log(txt.substr(-4)); // WXYZ, the position counts from the end of the string

// By default, the replace() method replaces only the first match (insensitive)
console.log(txt.replace("A", "*")); // *BCDEFGHIJKLMNOPQRSTUVWXYZ, returns a new string
// !BCDEFGHIJKLMNOPQRSTUVWXYZ, to replace case insensitive with an /i flag 
console.log(txt.replace(/a/i,"!")); 
// To replace all matches, use a regular expression with a /g flag (global match)
console.log(txt.replace(/A/g,"!")); // !BCDEFGHIJKLMNOPQRSTUVWXYZ

console.log(txt.replace(/A/g,"!"));

val = txt.toUpperCase(); // Converting to Upper Case
val = txt.toLowerCase(); // Converting to Lower Case
val = "123".concat("45", "67"); // '1234567', joins two or more strings
val = "  13 ".trim(); // '13', removes whitespace from both sides of a string
val = " 13".replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); //for IE8 or lower

console.log("123".charAt(0)); // 1, returns the character at a specified index
console.log("123".charCodeAt(0)); // 49, returns the unicode of character at index

console.log(txt[1]); // 'B', does not work in IE7 or earlier
// If no character is found, [ ] returns undefined, while charAt() returns an empty string

console.log("1,2,3".split(",")); // ["1", "2", "3"], Converting a String to an Array
console.log("1,2,3".split(""));  // ["1", ",", "2", ",", "3"], Split in characters

//-------------------------------------------------------------------------------
// OBJECT LITERALS
//-------------------------------------------------------------------------------
const person = {
  firstName: 'John',
  lastName: 'Doe',
  age: 30,
  hobbies: ['music', 'movies', 'sports'],
  address: {
    street: '50 Main st',
    city: 'New York',
    state: 'NY'
  },
  fullName: function() { 
    return this.firstName + " " + this.lastName; 
  }
}

console.log(person.firstName); // Get single value
console.log(person.hobbies[1]);  // Get array value
console.log(person.address.city);  // Get embedded object
console.log(person.fullName()); // function definition, stored as a property value
person.email = 'jdoe@gmail.com';  // Add property

// Array of objects
const todos = [
  {
    id: 1,
    text: 'Text1',
    isComplete: false
  },
  {
    id: 2,
    text: 'Text2',
    isComplete: false
  },
  {
    id: 3,
    text: 'Text3',
    isComplete: true
  }
];

console.log(todos[1].text);  // Get specific object value
console.log(JSON.stringify(todos));  // Format as JSON

//-------------------------------------------------------------------------------
// Do Not Declare Strings, Numbers, and Booleans as Objects!
x = String();        // Declares x as a String object, type object
var y = Number();    // Declares y as a Number object
var z = Boolean();   // Declares z as a Boolean object
// Comparing two JavaScript objects will always return false.

//-------------------------------------------------------------------------------
// Операторы сравнения (>, <, <=, >=, ==, !=) возвращают значение true/false
//-------------------------------------------------------------------------------
calc = 4 > 1; // calc=true, type boolean

calc = 'A' > 'Z'; // false, используется «алфавитный» или «лексикографический» порядок
// большей считается более длинная строка 'asdf' > 'asd' 
// имеет значение регистр символов 'a' > 'A'

// при сравнении значений разных типов JavaScript приводит каждое из них к числу
calc = '2' > 1; // true, 2>1
calc = '01' == 1; // true, строка '01' становится числом 1
calc = true == 1; // логическое значение true становится 1, а false – 0
calc = Boolean(0); // false
calc = Boolean('0'); // true

//Оператор строгого равенства === проверяет равенство без приведения типов
calc = 0 == false; // true
calc = '' == false; // true
calc = 0 === false; // false, так как сравниваются разные типы
calc = null === undefined; // false
calc = null == undefined; // true, равны друг другу и не равны никаким другим значениям

// При использовании математических операторов и других операторов сравнения < > <= >=
// Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN
calc =  null > 0;  // false
calc =  null == 0; // false,  для == значений undefined и null ни к чему не приводятся
calc =  null >= 0; // true, сравнения > < >= <= преобразуют null в 0

// Значение undefined несравнимо с другими. Возвращает false при любых сравненияx c NaN
calc = undefined > 0; // false, undefined преобразуется в NaN, 
calc = undefined < 0; // false
calc = undefined == 0; // false, undefined равно только null и ничему больше

// Note: осторожно при сравнении с undefined/null, кроме строгого равенства ===.
// Не используйте сравнения >= > < <= с переменными, которые могут быть null/undefined. 
// Если переменная может принимать эти значения, то добавьте для них отдельные проверки.

calc = 5 > 4; // true
calc = "ананас" > "яблоко"; // false, Используется посимвольное сравнение
calc = "2" > "12"; // true, символ первой строки "2" больше, чем первый символ второй "1"
calc = undefined == null; // true, Значения null и undefined равны друг другу при ==
calc = undefined === null; // false
calc = null == "\n0\n"; // false, null равен только undefined!!!
calc = null === +"\n0\n"; // false, Строгое сравнение разных типов

//-------------------------------------------------------------------------------
// TYPE CONVERSION 
// Численное преобразование происходит в остальных мат. функциях и выражениях
calc = "6" / "2"; // 3, type number	

// Преобразование к числу, унарный плюс +
calc = +1; // 1, унарный плюс ничего не делает с числами
calc = +-2;  // -2
calc = +'2';  // 2, преобразует нечисла в числа (то же самое, что и Number(...))
calc = +true; // 1
calc = +"";   // 0

let apples = "2", oranges = "3";
calc = apples + oranges; // "23", бинарный плюс сложит их как строки
calc = +apples + +oranges; // 5, оба операнда предварительно преобразованы в числа
calc = Number(apples) + Number(oranges); // 5, более длинный вариант

// Convert to string
let convertToString = String(123); // '123', type string
// By default, JavaScript displays numbers as base 10 decimals.
// But you can use the toString() method to output numbers from base 2 to base 36.
// Hexadecimal is base 16. Decimal is base 10. Octal is base 8. Binary is base 2.
let myNumber = 32;
myNumber.toString(10);  // returns 32 
myNumber.toString(32);  // returns 10 (decimal)
myNumber.toString(16);  // returns 20 (hexadecimal)
myNumber.toString(8);   // returns 40 (octal)
myNumber.toString(2);   // returns 100000 (binary)

// Convert to number
let convertToNumber = Number("123"); // 123, type number
convertToNumber = Number("123z"); // NaN, type number
// пробельные символы по краям обрезаются. Если остаётся пустая строка, 
// то 0, иначе «считывается» число. При ошибке результат NaN. 
convertToNumber = Number(undefined); // undefined преобразуется в NaN!!!
convertToNumber = Number(null); // null преобразуется в 0!!!
convertToNumber = Number(true); // true/false  преобразуется в 1/0
 
// Convert to boolean
// Значения: 0, null, undefined, NaN, "" преобразуются в false, 
// любое другое значение в true 
// "0" и строки из одних пробелов типа " " при логическом преобразовании всегда true
calc = Boolean(0); // false!!!
calc = Boolean("0"); // true!!!
calc = Boolean(""); // false
calc = Boolean(" "); // true (если строка не пустая, то она всегда true!!!)
 
calc = true + false; // 1, type number
calc = null + 1; // 1, type number (null становится 0 после численного преобразования) 
calc = undefined + 1; // NaN, type number (undefined становится NaN после числ.преобразования) 

// If you use NaN in a mathematical operation, the result will also be NaN
calc = NaN + 1; // NaN
calc = NaN + '1'; // NaN1

// Численное преобразование
let convertToInt = parseInt("1");  // 1, type number
let convertToFloat = parseFloat("1"); // 1, type number

//-------------------------------------------------------------------------------
// LOOPS
//-------------------------------------------------------------------------------
// For
for (let i = 0; i <= 10; i++){
  console.log(`For Loop Number: ${i}`);
}

// While
let i = 0;

while (i <= 10) {
  console.log(`While Loop Number: ${i}`);
  i++;
}

// Do While (will execute at least once)
i = 0;
do {
  console.log(`Do While Loop Number: ${i}`);
  i++;
} while (i < 3);

// Loop Through Arrays
// For Loop
for(let i = 0; i < todos.length; i++){
  console.log(` Todo ${i + 1}: ${todos[i].text}`);
}

// For...of Loop
for(let todo of todos) {
  console.log(todo.text);
}

// Continue
for (let i = 0; i < 10; i++) {
  if (i % 2 == 0) continue;
  console.log(i); // 1, затем 3, 5, 7, 9
}

// Break
let sum = 0;
while (true) {
  let value = +prompt("Enter number", '');
  if (!value) break; // (*)
  sum += value;
}
console.log( 'Sum: ' + sum );

// labelName: for(...) { ...} выйти одновременно из нескольких уровней цикла сразу.
// Вызов break <labelName> ищет ближайший внешний цикл с меткой и переходит в его конец
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, '');
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)
    // сделать что-нибудь со значениями...
  }
}
alert('Готово!');

// Директива continue также может быть использована с меткой. В этом случае 
// управление перейдёт на следующую итерацию цикла с меткой.
// Вызов break/continue возможен только внутри цикла, и метка должна 
// находиться где-то выше этой директивы.
// let i = 0; while (++i < 5) alert( i ); // От 1 до 4
// let i = 0; while (i++ < 5) alert( i ); // От 1 до 5

//-------------------------------------------------------------------------------
// CONDITIONALS
//-------------------------------------------------------------------------------
// Число 0, пустая строка "", null, undefined и NaN становятся false

// Simple If/Else Statement
const x = 30;
if (x === 10) {
  console.log('x is 10');
} else if (x > 10) {
  console.log('x is greater than 10');
} else {
  console.log('x is less than 10')
}

// Switch
let color = 'blue';
switch(color) {
  case 'red':
    console.log('color is red');
  case 'blue':
    console.log('color is blue');
  default:  
    console.log('color is not red or blue')
}

// Ternary operator / Shorthand if
const z = (color === 'red') ? 10 : 20;

let login;
let message = (login == 'Сотрудник') ? 'Привет' :
  (login == 'Директор') ? 'Здравствуйте' :
  (login == '') ? 'Нет логина' :
  '';

//-------------------------------------------------------------------------------
// JavaScript Numbers (Always 64-bit Floating Point)
//-------------------------------------------------------------------------------
// 64 bits: the fraction 0 to 51, the exponent in 52 to 62, and the sign in bit 63
x = 3.14;    // number with decimals
y = 3;       // number without decimals
x = 123e5;    // 12300000, with exponent
y = 123e-5;   // 0.00123

// Integers (numbers without a period or exponent notation) are accurate up to 15 digits
x = 999999999999999;   // x will be 999999999999999
y = 9999999999999999;  // y will be 10000000000000000

// The maximum number of decimals is 17, but floating point arithmetic is not always 100% accurate
x = 0.2 + 0.1;         // x will be 0.30000000000000004
// To solve the problem above, it helps to multiply and divide
x = (0.2 * 10 + 0.1 * 10) / 10;       // x will be 0.3

x = 0xFF; // x will be 255, preceded by 0x, are interpreted as hexadecimal
// Never write a number with a leading zero (like 07).
// Some JavaScript versions interpret numbers as octal if they are written with a leading zero.

//-------------------------------------------------------------------------------
	/*
	Список зарезервированных слов в JavaScript:
	abstract, break, byte, case, catch, char, class, const, continue, 
	debugger, default, delete, do, double, enum, export, extends, final, finally, float, 
	for, function, goto, implements, import, in, instanceof, int, inteface, long, 
	native, null, package, private, protected, public, return, short, static, super,
	switch, synchronized, this, throw, throws, transient, try, volatile, void, while, with	
	*/
//-------------------------------------------------------------------------------
</script>
</body>
</html>